---
layout: post
title: Property Objects, Scala, and Bindgen
---

Property Objects, Scala, and Bindgen
====================================

Data binding is an interesting topic because of large the effect it can have on an application's view layer.

A good data binding approach means your view layer is not wasting boilerplate LOC getting/setting data into/out of your domain model. Instead, ideally you succinctly bind `input <-> domain model` and, in 90% of the cases, be done with it.

I've used and built several data binding options and was recently reconsidering property objects dressed up in some of Scala's magic as a potentially elegant approach.

But, first, what I've done before, all admittedly biased towards the Java platform.

Basic Idea
----------

A `Binding` interface that looks like:

<pre name="code" class="java">
    public interface Binding[T] {
        T get();
        void set(T value);
        Class[T] getType();
    }
</pre>

Flush out why this interface is great--example of web framework converting data from Strings <-> value objects, etc.

Data Binding with OGNL
----------------------

I had a lot of success with [OGNL](http://www.ognl.org) and tweaking a [Click](http://click.sf.net)-based view layer to integrate with it. The basic idiom was:

<pre name="code" class="java">
    public class EmployeePage {
      public Employee employee;
      public Form form;

      public void onInit() {
        this.form = new Form();
        this.form.add(new Textbox("employee.firstName"));
        this.form.add(new Textbox("employee.lastName"));
      }
    }
</pre>

This one-line-per-field should be the goal of a good data binding approach. Click was spiffy enough to go ahead and generate the HTML for the form, so this meant that on the majority of the application's pages, each field originated from **1** line of code. Over a large enterprise app, that savings adds up.

**Pros and Cons of OGNL**

* Pro: succinct--1 line-per-field
* Pro: non-invasive--domain model doesn't know anything about OGNL, uses getters/setters
* Con: brittle--strings are opaque to the compiler and so break with refactoring

Other than being brittle OGNL is a great data binding solution. It sets a high standard that is the basis of comparison for the following approaches I've tried.

Data Binding with bindgen
-------------------------

When building [Joist](http://joist.ws), I wanted to solve the string-based brittleness issue of OGNL, so I built [bindgen](http://joist.ws/bindgen.html).

bindgen is a JDK6 annotation processor that hooks into the compiler's build cycle. It introspects any classes you annotate with `@Bindable` and generates type-safe binding classes for it.

For example, if you have a class `Employee`, bindgen will generate an `EmployeeBinding` class. If `Employee` has a `getName()` method that returns `String`, then `EmployeeBinding` will have a `name()` method that instead returns a `StringBinding`.

This `XxxBinding` instance has `get` and `set` methods on it, meaning you can pass the binding around into frameworks and they can easily get/convert/set your data.

Using it looks something like:

<pre name="code" class="java">
    @Bindable
    public class EmployeePage {
      public Employee employee;
      public Form form;

      public void onInit() {
        this.form = new Form();
        EmployeePageBinding b = new EmployeePageBinding(this);
        this.form.add(new Textbox(b.employee().firstName()));
        this.form.add(new Textbox(b.employee().lastName()));
      }
    }
</pre>

The big win here is that strings have gone away. If your `Employee` class changes, the `firstName()` and `lastName()` calls will fail to compile.

**Pros and Cons of bindgen**

* Pro: type-safe--no strings
* Pro: fast--the `XxxBinding` object's `get/set` methods are real methods (no generated bytecode/interpreting/etc.)
* Pro: non-invasive--the `@Bindable` annotation on the view will automatically recurse to the `Employee` domain object and so not require explicitly coupling your domain to bindgen
* Con: minor LOC overhead--the `@Bindable` and `EmployeePageBinding b` are constant (not per-field) syntactic costs
* Con: esoteric--JDK6 annotation processor support is still new and somewhat flaky in IDEs
* Con: Java-only--having being bitten by the Scala bug recently, it would be nice to write domain objects in Scala. Scala has compiler plugins, but there is no Scala bindgen implementation (yet)

All that said, I still really like bindgen. It takes an odd approach to data binding, but I like the results.

Data Binding with Property Objects
----------------------------------

Fowler talks about Property Objects in his [GUI Architectures](http://martinfowler.com/eaaDev/uiArchs.html) piece.

The basic idea is to promote the usual trio of:

* `private String name`
* `public String getName`
* `public void setName(String name)`

Into a single:

* `public StringProperty name()`

This makes a lot of sense, because now there is a single object representing the name, so it can be passed and have `get`/`set` methods called on it.

Which is great for frameworks.

But it does kind of suck (just a little) when you have to do:

<pre name="code" class="java">
    String name = employee.name().get();
</pre>

Instead of just the usual `getName()` that is all etched in our brains.

Using Scala for Property Objects
--------------------------------

But what if we could add some Scala magic? Here's an experiment:

<pre name="code" class="scala">
    import scala.collection.mutable.ListBuffer

    object PropertyObjectsTest {
      def main(args: Array[String]): Unit = {
        // First using explicit get/set methods
        val p1 = new Parent
        p1.name.set("Bob")
        println(p1.name.get)

        val c1 = new Child
        c1.name.set("Junior")
        p1.children.get += c1
        for (c &lt;- p1.children.get) {
          println(c.name.get)
        }

        // Now with spiffy implicit and := operator
        val p2 = new Parent
        p2.name := "Bob"
        println(p2.name)

        val c2 = new Child
        c2.name := "Junior"
        p2.children += c2
        for (c &lt;- p2.children) {
          println(c.name)
        }
      }
    }

    // Domain objects

    class Parent {
      val name = new StringProperty
      val children = new ListProperty[Child]
    }

    class Child {
      val name = new StringProperty
    }

    // Property trait, companion object, and implementations

    /** PropertyObject interface for getting/setting values. */
    trait Property[T] {
      /** @return the current value */
      def get: T

      /** @param value the new value */
      def set(value: T)

      /** @param value the new value via a ':=' operator */
      def :=(value: T)
    }

    /** Companion object to the Property trait. */
    object Property {
      /** Implicitly called to convert Property[T] -> T */
      implicit def p2value[T](p: Property[T]): T = p.get

      // E.g.:
      //   parent.name.endsWith("a")
      // Transparently becomes:
      //   parent.name.get().endsWith("a")
    }

    /** Simple base class for XxxProperty classes. */
    abstract class AbstractProperty[T] extends Property[T] {
      var value: T
      def get = value
      def set(value: T) = this.value = value
      def :=(value: T) = set(value)
      override def toString = this.getClass.getSimpleName+"[" + value + "]"
    }

    /** Wraps a string. */
    class StringProperty extends AbstractProperty[String] {
      override var value: String = null
    }

    /** Wraps a list. */
    class ListProperty[U] extends AbstractProperty[ListBuffer[U]] {
      override var value: ListBuffer[U] = new ListBuffer
    }
</pre>

Between the `:=` operator and the `p2value` implicit, we've basically made the Property Objects annoying extra `get()`/`set()` method calls go hide behind compiler syntax sugar.

I like `:=` too--it is succinct and just different enough to hint that it isn't a real `=` operation.

Very cool. Makes me want to crank out some Scala domain objects.

**Pros and Cons of Scala Property Objects**

* Pro: type-safe
* Pro: fast--just method calls
* Con: invasive--domain model must be changed to use `XxxProperty` objects. Though the `:=`/`implicit` aspects do make it more lightweight for users of the domain objects.

Except
------

Bindgen can do table rows, e.g. decouple the binding path from a given instance so we can have one binding evaluated against multiple root objects.

